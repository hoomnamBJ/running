<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>인터벌 러닝 타이머 - 거리 기반</title>
  <link rel="manifest" href="manifest.json">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 40px;
      background: linear-gradient(to bottom right, #e0f7fa, #ffffff);
    }
    input, select {
      font-size: 18px;
      margin: 10px;
      padding: 8px;
      width: 220px;
    }
    button {
      font-size: 18px;
      padding: 10px 20px;
      margin: 5px;
      background-color: #00b894;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
    #status {
      margin-top: 30px;
      font-size: 24px;
    }
    canvas, #map {
      margin-top: 40px;
      max-width: 600px;
      height: 300px;
    }
  </style>
</head>
<body>
  <h1>📍 거리 기반 인터벌 타이머</h1>

  <select id="mode">
    <option value="time">시간 기반</option>
    <option value="distance">거리 기반</option>
  </select>
  <br />

  <div id="timeInputs">
    <input type="number" id="runTime" placeholder="달리기 시간 (초)" min="1" />
    <br />
    <input type="number" id="walkTime" placeholder="걷기 시간 (초)" min="1" />
  </div>

  <div id="distanceInputs" style="display:none;">
    <input type="number" id="runDistance" placeholder="달리기 거리 (m)" min="10" />
    <br />
    <input type="number" id="walkDistance" placeholder="걷기 거리 (m)" min="10" />
  </div>

  <input type="number" id="repeatCount" placeholder="반복 횟수" min="1" />
  <br />
  <button onclick="startInterval()">⏱️ 시작</button>
  <button onclick="resetInterval()">❌ 종료</button>

  <div id="status">준비 완료</div>
  <canvas id="distanceChart"></canvas>
  <div id="map"></div>
  <a id="downloadLink" style="display:none" download="route.csv">📥 경로 저장</a>

  <script>
    let mode = "time";
    let currentSet = 0, totalSets = 0;
    let runPhaseActive = true;
    let watchId = null;
    let startCoords = null;
    let runDist = 0, walkDist = 0;
    let runTime = 0, walkTime = 0;
    let intervalId;
    let isRunning = false;
    let totalDistance = 0;
    let trackCoords = [];

    document.getElementById("mode").addEventListener("change", (e) => {
      mode = e.target.value;
      document.getElementById("timeInputs").style.display = mode === "time" ? "block" : "none";
      document.getElementById("distanceInputs").style.display = mode === "distance" ? "block" : "none";
    });

    function speak(text) {
      const msg = new SpeechSynthesisUtterance(text);
      msg.lang = 'ko-KR';
      window.speechSynthesis.speak(msg);
    }

    function startInterval() {
      if (isRunning) return;
      currentSet = 1;
      totalDistance = 0;
      trackCoords = [];
      drawMap();
      totalSets = parseInt(document.getElementById("repeatCount").value);
      if (isNaN(totalSets)) return alert("반복 횟수를 입력해주세요");

      if (mode === "time") {
        runTime = parseInt(document.getElementById("runTime").value);
        walkTime = parseInt(document.getElementById("walkTime").value);
        if (isNaN(runTime) || isNaN(walkTime)) return alert("시간을 모두 입력해주세요");
        isRunning = true;
        runTimePhase();
      } else {
        runDist = parseFloat(document.getElementById("runDistance").value);
        walkDist = parseFloat(document.getElementById("walkDistance").value);
        if (isNaN(runDist) || isNaN(walkDist)) return alert("거리를 모두 입력해주세요");
        isRunning = true;
        runDistancePhase();
      }
    }

    function runTimePhase() {
      document.getElementById("status").textContent = `🏃‍♂️ ${currentSet}세트 - 달리기!`;
      speak("달리기 시작!");
      intervalId = setTimeout(() => {
        walkTimePhase();
      }, runTime * 1000);
    }

    function walkTimePhase() {
      document.getElementById("status").textContent = `🚶‍♂️ ${currentSet}세트 - 걷기`;
      speak("걷기 시작!");
      intervalId = setTimeout(() => {
        currentSet++;
        if (currentSet <= totalSets) {
          runTimePhase();
        } else {
          endSession();
        }
      }, walkTime * 1000);
    }

    function runDistancePhase() {
      document.getElementById("status").textContent = `🏃‍♂️ ${currentSet}세트 - 달리기!`;
      speak("달리기 시작!");
      runPhaseActive = true;
      startTracking(runDist, walkDistancePhase);
    }

    function walkDistancePhase() {
      document.getElementById("status").textContent = `🚶‍♂️ ${currentSet}세트 - 걷기`;
      speak("걷기 시작!");
      runPhaseActive = false;
      startTracking(walkDist, () => {
        currentSet++;
        if (currentSet <= totalSets) {
          runDistancePhase();
        } else {
          endSession();
        }
      });
    }

    function startTracking(targetDistance, callback) {
      startCoords = null;
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude } = pos.coords;
        trackCoords.push([latitude, longitude]);
        if (!startCoords) {
          startCoords = { latitude, longitude };
        } else {
          const dist = getDistance(startCoords.latitude, startCoords.longitude, latitude, longitude);
          totalDistance += dist;
          drawDistanceChart();
          drawMap();
          if (dist >= targetDistance) {
            navigator.geolocation.clearWatch(watchId);
            callback();
          }
        }
      }, err => {
        alert("GPS 오류: 위치를 가져올 수 없습니다.");
      }, {
        enableHighAccuracy: true,
        maximumAge: 1000,
        timeout: 10000
      });
    }

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function endSession() {
      isRunning = false;
      document.getElementById("status").textContent = "🎉 인터벌 완료!";
      speak("인터벌 러닝 완료!");
      generateCSV();
    }

    function resetInterval() {
      clearTimeout(intervalId);
      if (watchId) navigator.geolocation.clearWatch(watchId);
      isRunning = false;
      document.getElementById("status").textContent = "준비 완료";
      totalDistance = 0;
      trackCoords = [];
      drawDistanceChart();
      drawMap();
      document.getElementById("downloadLink").style.display = "none";
    }

    function drawDistanceChart() {
      const ctx = document.getElementById("distanceChart").getContext("2d");
      const data = trackCoords.map((_, i) => i * 10);
      const values = trackCoords.map((_, i) => (i + 1) * (totalDistance / trackCoords.length));
      if (window.distChart) window.distChart.destroy();
      window.distChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: data,
          datasets: [{
            label: "누적 거리 (m)",
            data: values,
            borderColor: "#00b894",
            tension: 0.3,
            fill: false
          }]
        }
      });
    }

    function drawMap() {
      const container = document.getElementById("map");
      container.innerHTML = "";
      if (!trackCoords.length) return;
      const map = document.createElement("iframe");
      const path = trackCoords.map(p => p.join(",")).join("|");
      const url = `https://maps.googleapis.com/maps/api/staticmap?size=600x300&path=color:0x00b894ff|weight:4|${path}&key=YOUR_API_KEY`;
      map.src = url;
      map.width = "100%";
      map.height = "300";
      map.frameBorder = "0";
      container.appendChild(map);
    }

    function generateCSV() {
      let csv = "위도,경도\n" + trackCoords.map(p => p.join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const link = document.getElementById("downloadLink");
      link.href = url;
      link.style.display = "inline";
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }
  </script>
</body>
</html>
