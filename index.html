<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì¸í„°ë²Œ ëŸ¬ë‹ íƒ€ì´ë¨¸ - ê±°ë¦¬ ê¸°ë°˜</title>
  <link rel="manifest" href="manifest.json">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 40px;
      background: linear-gradient(to bottom right, #e0f7fa, #ffffff);
    }
    input, select {
      font-size: 18px;
      margin: 10px;
      padding: 8px;
      width: 220px;
    }
    button {
      font-size: 18px;
      padding: 10px 20px;
      margin: 5px;
      background-color: #00b894;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
    #status {
      margin-top: 30px;
      font-size: 24px;
    }
    canvas, #map {
      margin-top: 40px;
      max-width: 600px;
      height: 300px;
    }
  </style>
</head>
<body>
  <h1>ğŸ“ ê±°ë¦¬ ê¸°ë°˜ ì¸í„°ë²Œ íƒ€ì´ë¨¸</h1>

  <select id="mode">
    <option value="time">ì‹œê°„ ê¸°ë°˜</option>
    <option value="distance">ê±°ë¦¬ ê¸°ë°˜</option>
  </select>
  <br />

  <div id="timeInputs">
    <input type="number" id="runTime" placeholder="ë‹¬ë¦¬ê¸° ì‹œê°„ (ì´ˆ)" min="1" />
    <br />
    <input type="number" id="walkTime" placeholder="ê±·ê¸° ì‹œê°„ (ì´ˆ)" min="1" />
  </div>

  <div id="distanceInputs" style="display:none;">
    <input type="number" id="runDistance" placeholder="ë‹¬ë¦¬ê¸° ê±°ë¦¬ (m)" min="10" />
    <br />
    <input type="number" id="walkDistance" placeholder="ê±·ê¸° ê±°ë¦¬ (m)" min="10" />
  </div>

  <input type="number" id="repeatCount" placeholder="ë°˜ë³µ íšŸìˆ˜" min="1" />
  <br />
  <button onclick="startInterval()">â±ï¸ ì‹œì‘</button>
  <button onclick="resetInterval()">âŒ ì¢…ë£Œ</button>

  <div id="status">ì¤€ë¹„ ì™„ë£Œ</div>
  <canvas id="distanceChart"></canvas>
  <div id="map"></div>
  <a id="downloadLink" style="display:none" download="route.csv">ğŸ“¥ ê²½ë¡œ ì €ì¥</a>

  <script>
    let mode = "time";
    let currentSet = 0, totalSets = 0;
    let runPhaseActive = true;
    let watchId = null;
    let startCoords = null;
    let runDist = 0, walkDist = 0;
    let runTime = 0, walkTime = 0;
    let intervalId;
    let isRunning = false;
    let totalDistance = 0;
    let trackCoords = [];

    document.getElementById("mode").addEventListener("change", (e) => {
      mode = e.target.value;
      document.getElementById("timeInputs").style.display = mode === "time" ? "block" : "none";
      document.getElementById("distanceInputs").style.display = mode === "distance" ? "block" : "none";
    });

    function speak(text) {
      const msg = new SpeechSynthesisUtterance(text);
      msg.lang = 'ko-KR';
      window.speechSynthesis.speak(msg);
    }

    function startInterval() {
      if (isRunning) return;
      currentSet = 1;
      totalDistance = 0;
      trackCoords = [];
      drawMap();
      totalSets = parseInt(document.getElementById("repeatCount").value);
      if (isNaN(totalSets)) return alert("ë°˜ë³µ íšŸìˆ˜ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”");

      if (mode === "time") {
        runTime = parseInt(document.getElementById("runTime").value);
        walkTime = parseInt(document.getElementById("walkTime").value);
        if (isNaN(runTime) || isNaN(walkTime)) return alert("ì‹œê°„ì„ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”");
        isRunning = true;
        runTimePhase();
      } else {
        runDist = parseFloat(document.getElementById("runDistance").value);
        walkDist = parseFloat(document.getElementById("walkDistance").value);
        if (isNaN(runDist) || isNaN(walkDist)) return alert("ê±°ë¦¬ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”");
        isRunning = true;
        runDistancePhase();
      }
    }

    function runTimePhase() {
      document.getElementById("status").textContent = `ğŸƒâ€â™‚ï¸ ${currentSet}ì„¸íŠ¸ - ë‹¬ë¦¬ê¸°!`;
      speak("ë‹¬ë¦¬ê¸° ì‹œì‘!");
      intervalId = setTimeout(() => {
        walkTimePhase();
      }, runTime * 1000);
    }

    function walkTimePhase() {
      document.getElementById("status").textContent = `ğŸš¶â€â™‚ï¸ ${currentSet}ì„¸íŠ¸ - ê±·ê¸°`;
      speak("ê±·ê¸° ì‹œì‘!");
      intervalId = setTimeout(() => {
        currentSet++;
        if (currentSet <= totalSets) {
          runTimePhase();
        } else {
          endSession();
        }
      }, walkTime * 1000);
    }

    function runDistancePhase() {
      document.getElementById("status").textContent = `ğŸƒâ€â™‚ï¸ ${currentSet}ì„¸íŠ¸ - ë‹¬ë¦¬ê¸°!`;
      speak("ë‹¬ë¦¬ê¸° ì‹œì‘!");
      runPhaseActive = true;
      startTracking(runDist, walkDistancePhase);
    }

    function walkDistancePhase() {
      document.getElementById("status").textContent = `ğŸš¶â€â™‚ï¸ ${currentSet}ì„¸íŠ¸ - ê±·ê¸°`;
      speak("ê±·ê¸° ì‹œì‘!");
      runPhaseActive = false;
      startTracking(walkDist, () => {
        currentSet++;
        if (currentSet <= totalSets) {
          runDistancePhase();
        } else {
          endSession();
        }
      });
    }

    function startTracking(targetDistance, callback) {
      startCoords = null;
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude } = pos.coords;
        trackCoords.push([latitude, longitude]);
        if (!startCoords) {
          startCoords = { latitude, longitude };
        } else {
          const dist = getDistance(startCoords.latitude, startCoords.longitude, latitude, longitude);
          totalDistance += dist;
          drawDistanceChart();
          drawMap();
          if (dist >= targetDistance) {
            navigator.geolocation.clearWatch(watchId);
            callback();
          }
        }
      }, err => {
        alert("GPS ì˜¤ë¥˜: ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }, {
        enableHighAccuracy: true,
        maximumAge: 1000,
        timeout: 10000
      });
    }

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function endSession() {
      isRunning = false;
      document.getElementById("status").textContent = "ğŸ‰ ì¸í„°ë²Œ ì™„ë£Œ!";
      speak("ì¸í„°ë²Œ ëŸ¬ë‹ ì™„ë£Œ!");
      generateCSV();
    }

    function resetInterval() {
      clearTimeout(intervalId);
      if (watchId) navigator.geolocation.clearWatch(watchId);
      isRunning = false;
      document.getElementById("status").textContent = "ì¤€ë¹„ ì™„ë£Œ";
      totalDistance = 0;
      trackCoords = [];
      drawDistanceChart();
      drawMap();
      document.getElementById("downloadLink").style.display = "none";
    }

    function drawDistanceChart() {
      const ctx = document.getElementById("distanceChart").getContext("2d");
      const data = trackCoords.map((_, i) => i * 10);
      const values = trackCoords.map((_, i) => (i + 1) * (totalDistance / trackCoords.length));
      if (window.distChart) window.distChart.destroy();
      window.distChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: data,
          datasets: [{
            label: "ëˆ„ì  ê±°ë¦¬ (m)",
            data: values,
            borderColor: "#00b894",
            tension: 0.3,
            fill: false
          }]
        }
      });
    }

    function drawMap() {
      const container = document.getElementById("map");
      container.innerHTML = "";
      if (!trackCoords.length) return;
      const map = document.createElement("iframe");
      const path = trackCoords.map(p => p.join(",")).join("|");
      const url = `https://maps.googleapis.com/maps/api/staticmap?size=600x300&path=color:0x00b894ff|weight:4|${path}&key=YOUR_API_KEY`;
      map.src = url;
      map.width = "100%";
      map.height = "300";
      map.frameBorder = "0";
      container.appendChild(map);
    }

    function generateCSV() {
      let csv = "ìœ„ë„,ê²½ë„\n" + trackCoords.map(p => p.join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const link = document.getElementById("downloadLink");
      link.href = url;
      link.style.display = "inline";
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }
  </script>
</body>
</html>
